lines = []
all_lines = open("salida.txt").readlines()
size = len(all_lines)
count = 0

# TODO: check that they're actually hidden
HIDDEN_METHODS = [
	'getAccessibilityNodeProvider',
	'getIteratorForGranularity',
	'getViewRootImpl',
	'getHardwareRenderer',
	'getDisplayList',
]

def generate_new_line(new_line):
	method_name, arguments = new_line.split('(')
	arguments, trailing    = arguments.split(')')

	new_arguments = []
	for argument in arguments.split(','):
		if argument.strip() != '':
			new_arguments.append(argument.split()[-1])

	return method_name + '(' + ', '.join(new_arguments) + ')' + trailing


while count < size:
	new_line = all_lines[count]

	if new_line.strip().endswith(')'):
		new_line = new_line.strip() + ' {\n'

	if (new_line.startswith('protected') or new_line.startswith('public')):
		return_type = new_line.split()[1]
		if return_type == 'void':
			return_code = ""
			end_sentence = ""
		else:
			native_types = { 'boolean' : 'Boolean', 'int' : 'Integer', 'float' : 'Float', 'long' : 'Long' }
			return_code = "return (%s)(" % native_types.get(return_type, return_type)
			end_sentence = ")"
		original_arguments = new_line.split('(')[1].split(')')[0]

		next_line = all_lines[count + 1].strip()
		next_line = generate_new_line(next_line)
		method_name, arguments = next_line.split('this.impl.')[1].split('(')

		if method_name in HIDDEN_METHODS:
			print "Skipping", method_name
			count += 4
			continue

		lines.append("/** Autogenerated code. Do not edit, but run the Python script again. */\n")
		lines.append(new_line)
		if len(original_arguments) > 0:
			arguments_parsed = [ [ i.strip() for i in arg.split() if i.strip() != 'final' ] for arg in original_arguments.split(',') ]
			full_list = []
			for arg_type, arg_name in arguments_parsed:
				if arg_type == 'int':
					full_list.append('Integer.TYPE')
				elif arg_type == 'boolean':
					full_list.append('Boolean.TYPE')
				else:
					full_list.append('%s.class' % arg_type)
			processed_args = ', '.join(full_list)
			arguments_before = arguments.split(';')[0]
			generation_code = '    %sgetMethodInParents("%s", %s).invoke(this.impl, %s%s;\n' % (return_code, method_name, processed_args, arguments_before, end_sentence)
		else:
			arguments_before = ""
			processed_args   = ""
			generation_code  = '    %sgetMethodInParents("%s").invoke(this.impl, (Object[])null)%s;\n' % (return_code, method_name, end_sentence)
	
		generation_code = (  """    if (this.impl == null) {\n""" +
				     """        registerCall("%s", new Class<?>[]{ %s } %s%s);\n""" % (method_name, processed_args, ', ' if len(arguments_before) > 0 else '', arguments_before.replace(')','')) +
				     """        %s\n""" % ('return;' if return_type == 'void' else '') +
				     """    }\n""" +
				     """    \n""" +
				     """    try {\n    """ +
				     generation_code +
				     """    } catch (Exception e) {\n""" +
				    ("""        throw new ProxyException("Error executing method '%s' of class '" + this.impl.getClass().getName() + "'. Message:" + e.getMessage(), e);\n""" % method_name) +
				     """    }\n """ )
		next_line = "/* reflection code for\n %s\n%s\n */\n" % (next_line, generation_code)
		next_line = generation_code
		lines.append(next_line)
		count += 2
		continue

	if 'this.impl.' in new_line:
		new_line = generate_new_line(new_line)

	lines.append(new_line)
	count += 1

salida = open('salida_pero_molando_edu.txt', 'w')
print >> salida, ''.join(lines)
